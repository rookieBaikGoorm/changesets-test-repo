#!/bin/bash
#
# Git Flow Release Hook - Automatic Version Update
#
# This hook runs before 'git flow release finish'
# It automatically runs changeset version and commits the updates
#

set -e

# 색상 정의
WHITE='\033[37m'
RED='\033[31m'
GREEN='\033[32m'
RESET='\033[0m'

BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || echo "")

# release 브랜치인지 확인
if [[ ! $BRANCH =~ ^release/ ]]; then
  echo "⚠️  Release 브랜치가 아닙니다: $BRANCH"
  exit 0
fi

echo ""
echo -e "${WHITE}Git Flow Release Hook 실행${RESET}"
echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RESET}"
echo ""

# Changeset 파일 확인
CHANGESET_FILES=$(ls .changeset/*.md 2>/dev/null | grep -v README.md || echo "")

if [ -z "$CHANGESET_FILES" ]; then
  echo -e "${WHITE}1️⃣ Changeset 파일이 없습니다.${RESET}"
  echo ""
  echo -e "${WHITE}   Git Commit 분석 및 Changeset 자동 생성 중...${RESET}"

  # 베이스 브랜치 찾기 (release 브랜치는 main과 비교)
  BASE_BRANCH="main"
  if ! git rev-parse --verify main >/dev/null 2>&1; then
    echo -e "   ⎿ ${RED}✗${RESET}${WHITE} main 브랜치를 찾을 수 없습니다${RESET}"
    exit 1
  fi

  echo -e "${WHITE}   ⎿ 베이스 브랜치: $BASE_BRANCH${RESET}"
  echo ""

  # 임시 디렉토리 생성 (데이터 저장용)
  TMP_DIR=$(mktemp -d)
  trap "rm -rf $TMP_DIR" EXIT

  # packages 및 apps 디렉토리의 패키지 정보 수집
  echo "" > "$TMP_DIR/packages.txt"
  for pkg_dir in packages/*/ apps/*/; do
    if [ -f "${pkg_dir}package.json" ]; then
      pkg_name=$(cat "${pkg_dir}package.json" | grep '"name"' | head -1 | sed 's/.*"name": "\(.*\)".*/\1/')
      pkg_path="${pkg_dir%/}"
      echo "$pkg_path|$pkg_name" >> "$TMP_DIR/packages.txt"
    fi
  done

  # 커밋 목록 가져오기
  commits=$(git log $BASE_BRANCH..HEAD --format=%H --reverse)

  if [ -z "$commits" ]; then
    echo -e "${WHITE}   ⎿ ${RED}✗${RESET}${WHITE} 새로운 커밋이 없습니다${RESET}"
    echo ""
    echo -e "${WHITE}   버전 변경 없이 계속 진행합니다${RESET}"
    exit 0
  fi

  echo -e "${WHITE}   ⎿ 분석 중인 커밋:${RESET}"
  for commit in $commits; do
    msg=$(git log -1 --format=%s $commit)
    echo -e "${WHITE}      • $msg${RESET}"

    # Conventional Commits 파싱
    bump_type="patch"
    description=""

    # BREAKING CHANGE 또는 ! 체크 (major)
    if echo "$msg${RESET}" | grep -qE '!:|BREAKING CHANGE'; then
      bump_type="major"
      description=$(echo "$msg${RESET}" | sed -E 's/^[a-z]+(\([^)]+\))?!?: //')
    # feat: 체크 (minor)
    elif echo "$msg${RESET}" | grep -qE '^feat(\([^)]+\))?: '; then
      bump_type="minor"
      description=$(echo "$msg${RESET}" | sed -E 's/^feat(\([^)]+\))?: //')
    # fix: 체크 (patch)
    elif echo "$msg${RESET}" | grep -qE '^fix(\([^)]+\))?: '; then
      bump_type="patch"
      description=$(echo "$msg${RESET}" | sed -E 's/^fix(\([^)]+\))?: //')
    # 기타 (무시하거나 patch)
    elif echo "$msg${RESET}" | grep -qE '^(chore|docs|style|refactor|test|perf|ci|build)(\([^)]+\))?: '; then
      continue  # 이런 커밋은 changeset에 포함하지 않음
    else
      # 컨벤션을 따르지 않는 커밋은 patch로 처리
      description="$msg${RESET}"
    fi

    # 변경된 파일 확인
    changed_files=$(git diff-tree --no-commit-id --name-only -r $commit)

    # 각 패키지별로 분류
    while IFS='|' read -r pkg_path pkg_name; do
      if [ -z "$pkg_path" ]; then continue; fi

      if echo "$changed_files" | grep -q "^$pkg_path/"; then
        # 패키지별 데이터 파일
        pkg_data_file="$TMP_DIR/$(echo "$pkg_name" | sed 's/[@\/]/_/g').txt"

        # description 추가
        echo "- $description" >> "$pkg_data_file"

        # bump type 업데이트 (major > minor > patch)
        bump_file="$TMP_DIR/$(echo "$pkg_name" | sed 's/[@\/]/_/g').bump"
        current_bump=""
        if [ -f "$bump_file" ]; then
          current_bump=$(cat "$bump_file")
        fi

        new_bump="$current_bump"
        if [ "$bump_type" = "major" ]; then
          new_bump="major"
        elif [ "$bump_type" = "minor" ] && [ "$current_bump" != "major" ]; then
          new_bump="minor"
        elif [ -z "$current_bump" ]; then
          new_bump="$bump_type"
        fi

        if [ "$new_bump" != "$current_bump" ]; then
          echo "$new_bump" > "$bump_file"
        fi
      fi
    done < "$TMP_DIR/packages.txt"
  done

  echo ""

  # Changeset 파일 생성
  package_count=$(find "$TMP_DIR" -name "*.bump" 2>/dev/null | wc -l)
  if [ "$package_count" -eq 0 ]; then
    echo -e "${WHITE}   ⎿ ${RED}✗${RESET}${WHITE} 변경된 패키지가 없습니다${RESET}"
    echo ""
    echo -e "${WHITE}   버전 변경 없이 계속 진행합니다${RESET}"
    exit 0
  fi

  echo ""
  echo -e "${WHITE}   ⎿ 생성된 Changeset:${RESET}"
  echo ""

  changeset_id="auto-$(date +%s)"
  changeset_file=".changeset/${changeset_id}.md"

  # Changeset 파일 작성
  {
    echo "---"
    # frontmatter 작성
    while IFS='|' read -r pkg_path pkg_name; do
      if [ -z "$pkg_path" ]; then continue; fi

      bump_file="$TMP_DIR/$(echo "$pkg_name" | sed 's/[@\/]/_/g').bump"
      if [ -f "$bump_file" ]; then
        bump_type=$(cat "$bump_file")
        echo "\"$pkg_name\": $bump_type"
      fi
    done < "$TMP_DIR/packages.txt"

    echo "---"
    echo ""

    # 변경 내용 작성
    while IFS='|' read -r pkg_path pkg_name; do
      if [ -z "$pkg_path" ]; then continue; fi

      pkg_data_file="$TMP_DIR/$(echo "$pkg_name" | sed 's/[@\/]/_/g').txt"
      if [ -f "$pkg_data_file" ]; then
        cat "$pkg_data_file"
        echo ""
      fi
    done < "$TMP_DIR/packages.txt"
  } > "$changeset_file${RESET}"

  # 생성된 내용 표시
  cat "$changeset_file${RESET}" | sed 's/^/      /'
  echo ""

  echo -e "${WHITE}      ${GREEN}✓${RESET}${WHITE} Changeset 파일 생성 완료: $changeset_file${RESET}"
  echo ""

  # 다시 changeset 파일 확인
  CHANGESET_FILES=$(ls .changeset/*.md 2>/dev/null | grep -v README.md || echo "")
fi

echo -e "${WHITE}   발견된 Changeset 파일:${RESET}"
for file in $CHANGESET_FILES; do
  echo -e "${WHITE}   ⎿ $(basename $file)${RESET}"
done
echo ""

# 변경사항이 있는지 확인 (.changeset 파일 제외)
CHANGES=$(git status --porcelain | grep -v "^.. .changeset/" || true)
if [ -n "$CHANGES" ]; then
  echo -e "${WHITE}경고: 커밋되지 않은 변경사항이 있습니다${RESET}"
  echo "$CHANGES" | sed 's/^/   ⎿ /'
  echo ""
  read -p "스태시하고 계속하시겠습니까? (y/N): " -n 1 -r
  echo ""
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    git stash push -m "pre-release-hook-stash"
    STASHED=true
  else
    echo "Release 중단"
    exit 1
  fi
fi

# Changeset version 실행
echo -e "${WHITE}2️⃣ 버전 업데이트 실행 중...${RESET}"
if ! pnpm changeset version; then
  echo -e "   ⎿ ${RED}✗${RESET}${WHITE} Changeset version 실패${RESET}"
  exit 1
fi
echo -e "${WHITE}   ⎿ ${GREEN}✓${RESET}${WHITE} 버전 업데이트 완료${RESET}"
echo ""

# 변경사항 확인
if [ -z "$(git status --porcelain)" ]; then
  echo -e "${WHITE}   변경사항이 없습니다${RESET}"
  if [ "$STASHED" = true ]; then
    git stash pop
  fi
  exit 0
fi

# 업데이트된 내용 표시
echo -e "${WHITE}   업데이트된 파일:${RESET}"
git status --short | sed 's/^/   ⎿ /'
echo ""

# 커밋
echo -e "${WHITE}3️⃣ 변경사항 커밋 중...${RESET}"
git add .
git commit -m "chore(release): version packages

Auto-generated by git-flow pre-release hook"

echo -e "${WHITE}   ⎿ ${GREEN}✓${RESET}${WHITE} 커밋 완료${RESET}"
echo ""

# Stash 복구
if [ "$STASHED" = true ]; then
  git stash pop
fi

echo -e "${WHITE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo -e "${GREEN}✓ Release Hook 완료${RESET} - git flow release finish 계속 진행"
echo ""

exit 0





